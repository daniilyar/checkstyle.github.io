<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Main.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checkstyle</a> &gt; <a href="index.source.html" class="el_package">com.puppycrawl.tools.checkstyle</a> &gt; <span class="el_source">Main.java</span></div><h1>Main.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2018 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.puppycrawl.tools.checkstyle;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.logging.ConsoleHandler;
import java.util.logging.Filter;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.google.common.io.Closeables;
import com.puppycrawl.tools.checkstyle.api.AuditListener;
import com.puppycrawl.tools.checkstyle.api.AutomaticBean;
import com.puppycrawl.tools.checkstyle.api.CheckstyleException;
import com.puppycrawl.tools.checkstyle.api.Configuration;
import com.puppycrawl.tools.checkstyle.api.LocalizedMessage;
import com.puppycrawl.tools.checkstyle.api.RootModule;
import com.puppycrawl.tools.checkstyle.utils.CommonUtils;

/**
 * Wrapper command line program for the Checker.
 * @author the original author or authors.
 * @noinspection UseOfSystemOutOrSystemErr
 **/
public final class Main {

    /**
     * A key pointing to the error counter
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String ERROR_COUNTER = &quot;Main.errorCounter&quot;;
    /**
     * A key pointing to the load properties exception
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String LOAD_PROPERTIES_EXCEPTION = &quot;Main.loadProperties&quot;;
    /**
     * A key pointing to the create listener exception
     * message in the &quot;messages.properties&quot; file.
     */
    public static final String CREATE_LISTENER_EXCEPTION = &quot;Main.createListener&quot;;
    /** Logger for Main. */
<span class="fc" id="L80">    private static final Log LOG = LogFactory.getLog(Main.class);</span>

    /** Width of CLI help option. */
    private static final int HELP_WIDTH = 100;

    /** Exit code returned when execution finishes with {@link CheckstyleException}. */
    private static final int EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE = -2;

    /** Name for the option 'v'. */
    private static final String OPTION_V_NAME = &quot;v&quot;;

    /** Name for the option 'c'. */
    private static final String OPTION_C_NAME = &quot;c&quot;;

    /** Name for the option 'f'. */
    private static final String OPTION_F_NAME = &quot;f&quot;;

    /** Name for the option 'p'. */
    private static final String OPTION_P_NAME = &quot;p&quot;;

    /** Name for the option 'o'. */
    private static final String OPTION_O_NAME = &quot;o&quot;;

    /** Name for the option 't'. */
    private static final String OPTION_T_NAME = &quot;t&quot;;

    /** Name for the option '--tree'. */
    private static final String OPTION_TREE_NAME = &quot;tree&quot;;

    /** Name for the option '-T'. */
    private static final String OPTION_CAPITAL_T_NAME = &quot;T&quot;;

    /** Name for the option '--treeWithComments'. */
    private static final String OPTION_TREE_COMMENT_NAME = &quot;treeWithComments&quot;;

    /** Name for the option '-j'. */
    private static final String OPTION_J_NAME = &quot;j&quot;;

    /** Name for the option '--javadocTree'. */
    private static final String OPTION_JAVADOC_TREE_NAME = &quot;javadocTree&quot;;

    /** Name for the option '-J'. */
    private static final String OPTION_CAPITAL_J_NAME = &quot;J&quot;;

    /** Name for the option '--treeWithJavadoc'. */
    private static final String OPTION_TREE_JAVADOC_NAME = &quot;treeWithJavadoc&quot;;

    /** Name for the option '-d'. */
    private static final String OPTION_D_NAME = &quot;d&quot;;

    /** Name for the option '--debug'. */
    private static final String OPTION_DEBUG_NAME = &quot;debug&quot;;

    /** Name for the option 'e'. */
    private static final String OPTION_E_NAME = &quot;e&quot;;

    /** Name for the option '--exclude'. */
    private static final String OPTION_EXCLUDE_NAME = &quot;exclude&quot;;

    /** Name for the option '--executeIgnoredModules'. */
    private static final String OPTION_EXECUTE_IGNORED_MODULES_NAME = &quot;executeIgnoredModules&quot;;

    /** Name for the option 'x'. */
    private static final String OPTION_X_NAME = &quot;x&quot;;

    /** Name for the option '--exclude-regexp'. */
    private static final String OPTION_EXCLUDE_REGEXP_NAME = &quot;exclude-regexp&quot;;

    /** Name for the option '-C'. */
    private static final String OPTION_CAPITAL_C_NAME = &quot;C&quot;;

    /** Name for the option '--checker-threads-number'. */
    private static final String OPTION_CHECKER_THREADS_NUMBER_NAME = &quot;checker-threads-number&quot;;

    /** Name for the option '-W'. */
    private static final String OPTION_CAPITAL_W_NAME = &quot;W&quot;;

    /** Name for the option '--tree-walker-threads-number'. */
    private static final String OPTION_TREE_WALKER_THREADS_NUMBER_NAME =
        &quot;tree-walker-threads-number&quot;;

    /** Name for 'xml' format. */
    private static final String XML_FORMAT_NAME = &quot;xml&quot;;

    /** Name for 'plain' format. */
    private static final String PLAIN_FORMAT_NAME = &quot;plain&quot;;

    /** A string value of 1. */
    private static final String ONE_STRING_VALUE = &quot;1&quot;;

    /** Don't create instance of this class, use {@link #main(String[])} method instead. */
    private Main() {
    }

    /**
     * Loops over the files specified checking them for errors. The exit code
     * is the number of errors found in all the files.
     * @param args the command line arguments.
     * @throws IOException if there is a problem with files access
     * @noinspection CallToPrintStackTrace, CallToSystemExit
     **/
    public static void main(String... args) throws IOException {
<span class="fc" id="L182">        int errorCounter = 0;</span>
<span class="fc" id="L183">        boolean cliViolations = false;</span>
        // provide proper exit code based on results.
<span class="fc" id="L185">        final int exitWithCliViolation = -1;</span>
<span class="fc" id="L186">        int exitStatus = 0;</span>

        try {
            //parse CLI arguments
<span class="fc" id="L190">            final CommandLine commandLine = parseCli(args);</span>

            // show version and exit if it is requested
<span class="fc bfc" id="L193" title="All 2 branches covered.">            if (commandLine.hasOption(OPTION_V_NAME)) {</span>
<span class="fc" id="L194">                System.out.println(&quot;Checkstyle version: &quot;</span>
<span class="fc" id="L195">                        + Main.class.getPackage().getImplementationVersion());</span>
<span class="fc" id="L196">                exitStatus = 0;</span>
            }
            else {
<span class="fc" id="L199">                final List&lt;File&gt; filesToProcess = getFilesToProcess(getExclusions(commandLine),</span>
<span class="fc" id="L200">                        commandLine.getArgs());</span>

                // return error if something is wrong in arguments
<span class="fc" id="L203">                final List&lt;String&gt; messages = validateCli(commandLine, filesToProcess);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">                cliViolations = !messages.isEmpty();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">                if (cliViolations) {</span>
<span class="fc" id="L206">                    exitStatus = exitWithCliViolation;</span>
<span class="fc" id="L207">                    errorCounter = 1;</span>
<span class="fc" id="L208">                    messages.forEach(System.out::println);</span>
                }
                else {
<span class="fc" id="L211">                    errorCounter = runCli(commandLine, filesToProcess);</span>
<span class="fc" id="L212">                    exitStatus = errorCounter;</span>
                }
            }
        }
<span class="fc" id="L216">        catch (ParseException pex) {</span>
            // something wrong with arguments - print error and manual
<span class="fc" id="L218">            cliViolations = true;</span>
<span class="fc" id="L219">            exitStatus = exitWithCliViolation;</span>
<span class="fc" id="L220">            errorCounter = 1;</span>
<span class="fc" id="L221">            System.out.println(pex.getMessage());</span>
<span class="fc" id="L222">            printUsage();</span>
        }
<span class="fc" id="L224">        catch (CheckstyleException ex) {</span>
<span class="fc" id="L225">            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;</span>
<span class="fc" id="L226">            errorCounter = 1;</span>
<span class="fc" id="L227">            ex.printStackTrace();</span>
        }
        finally {
            // return exit code base on validation of Checker
            // two ifs exist till https://github.com/hcoles/pitest/issues/377
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if (errorCounter != 0) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (!cliViolations) {</span>
<span class="fc" id="L234">                    final LocalizedMessage errorCounterMessage = new LocalizedMessage(0,</span>
                            Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,
<span class="fc" id="L236">                            new String[] {String.valueOf(errorCounter)}, null, Main.class, null);</span>
<span class="fc" id="L237">                    System.out.println(errorCounterMessage.getMessage());</span>
                }
            }
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (exitStatus != 0) {</span>
<span class="fc" id="L241">                System.exit(exitStatus);</span>
            }
        }
<span class="fc" id="L244">    }</span>

    /**
     * Parses and executes Checkstyle based on passed arguments.
     * @param args
     *        command line parameters
     * @return parsed information about passed parameters
     * @throws ParseException
     *         when passed arguments are not valid
     */
    private static CommandLine parseCli(String... args)
            throws ParseException {
        // parse the parameters
<span class="fc" id="L257">        final CommandLineParser clp = new DefaultParser();</span>
        // always returns not null value
<span class="fc" id="L259">        return clp.parse(buildOptions(), args);</span>
    }

    /**
     * Gets the list of exclusions provided through the command line argument.
     * @param commandLine command line object
     * @return List of exclusion patterns.
     */
    private static List&lt;Pattern&gt; getExclusions(CommandLine commandLine) {
<span class="fc" id="L268">        final List&lt;Pattern&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_E_NAME)) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            for (String value : commandLine.getOptionValues(OPTION_E_NAME)) {</span>
<span class="fc" id="L272">                result.add(Pattern.compile(&quot;^&quot; + Pattern.quote(new File(value).getAbsolutePath())</span>
                        + &quot;$&quot;));
            }
        }
<span class="fc bfc" id="L276" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_X_NAME)) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            for (String value : commandLine.getOptionValues(OPTION_X_NAME)) {</span>
<span class="fc" id="L278">                result.add(Pattern.compile(value));</span>
            }
        }

<span class="fc" id="L282">        return result;</span>
    }

    /**
     * Do validation of Command line options.
     * @param cmdLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return list of violations
     */
    // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation
    private static List&lt;String&gt; validateCli(CommandLine cmdLine, List&lt;File&gt; filesToProcess) {
<span class="fc" id="L293">        final List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (filesToProcess.isEmpty()) {</span>
<span class="fc" id="L296">            result.add(&quot;Files to process must be specified, found 0.&quot;);</span>
        }
        // ensure there is no conflicting options
<span class="fc bfc" id="L299" title="All 4 branches covered.">        else if (cmdLine.hasOption(OPTION_T_NAME) || cmdLine.hasOption(OPTION_CAPITAL_T_NAME)</span>
<span class="fc bfc" id="L300" title="All 4 branches covered.">                || cmdLine.hasOption(OPTION_J_NAME) || cmdLine.hasOption(OPTION_CAPITAL_J_NAME)) {</span>
<span class="fc bfc" id="L301" title="All 4 branches covered.">            if (cmdLine.hasOption(OPTION_C_NAME) || cmdLine.hasOption(OPTION_P_NAME)</span>
<span class="fc bfc" id="L302" title="All 4 branches covered.">                    || cmdLine.hasOption(OPTION_F_NAME) || cmdLine.hasOption(OPTION_O_NAME)) {</span>
<span class="fc" id="L303">                result.add(&quot;Option '-t' cannot be used with other options.&quot;);</span>
            }
<span class="fc bfc" id="L305" title="All 2 branches covered.">            else if (filesToProcess.size() &gt; 1) {</span>
<span class="fc" id="L306">                result.add(&quot;Printing AST is allowed for only one file.&quot;);</span>
            }
        }
        // ensure a configuration file is specified
<span class="fc bfc" id="L310" title="All 2 branches covered.">        else if (cmdLine.hasOption(OPTION_C_NAME)) {</span>
<span class="fc" id="L311">            final String configLocation = cmdLine.getOptionValue(OPTION_C_NAME);</span>
            try {
                // test location only
<span class="fc" id="L314">                CommonUtils.getUriByFilename(configLocation);</span>
            }
<span class="fc" id="L316">            catch (CheckstyleException ignored) {</span>
<span class="fc" id="L317">                result.add(String.format(&quot;Could not find config XML file '%s'.&quot;, configLocation));</span>
<span class="fc" id="L318">            }</span>

            // validate optional parameters
<span class="fc bfc" id="L321" title="All 2 branches covered.">            if (cmdLine.hasOption(OPTION_F_NAME)) {</span>
<span class="fc" id="L322">                final String format = cmdLine.getOptionValue(OPTION_F_NAME);</span>
<span class="fc bfc" id="L323" title="All 4 branches covered.">                if (!PLAIN_FORMAT_NAME.equals(format) &amp;&amp; !XML_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L324">                    result.add(String.format(&quot;Invalid output format.&quot;</span>
                            + &quot; Found '%s' but expected '%s' or '%s'.&quot;,
                            format, PLAIN_FORMAT_NAME, XML_FORMAT_NAME));
                }
            }
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (cmdLine.hasOption(OPTION_P_NAME)) {</span>
<span class="fc" id="L330">                final String propertiesLocation = cmdLine.getOptionValue(OPTION_P_NAME);</span>
<span class="fc" id="L331">                final File file = new File(propertiesLocation);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                if (!file.exists()) {</span>
<span class="fc" id="L333">                    result.add(String.format(&quot;Could not find file '%s'.&quot;, propertiesLocation));</span>
                }
            }
<span class="fc" id="L336">            verifyThreadsNumberParameter(cmdLine, result, OPTION_CAPITAL_C_NAME,</span>
                &quot;Checker threads number must be greater than zero&quot;,
                &quot;Invalid Checker threads number&quot;);
<span class="fc" id="L339">            verifyThreadsNumberParameter(cmdLine, result, OPTION_CAPITAL_W_NAME,</span>
                &quot;TreeWalker threads number must be greater than zero&quot;,
                &quot;Invalid TreeWalker threads number&quot;);
<span class="fc" id="L342">        }</span>
        else {
<span class="fc" id="L344">            result.add(&quot;Must specify a config XML file.&quot;);</span>
        }

<span class="fc" id="L347">        return result;</span>
    }

    /**
     * Verifies threads number CLI parameter value.
     * @param cmdLine a command line
     * @param result a resulting list of errors
     * @param cliParameterName a CLI parameter name
     * @param mustBeGreaterThanZeroMessage a message which should be reported
     *                                     if the number of threads is less than or equal to zero
     * @param invalidNumberMessage a message which should be reported if the passed value
     *                             is not a valid number
     */
    private static void verifyThreadsNumberParameter(CommandLine cmdLine, List&lt;String&gt; result,
        String cliParameterName, String mustBeGreaterThanZeroMessage,
        String invalidNumberMessage) {
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (cmdLine.hasOption(cliParameterName)) {</span>
<span class="fc" id="L364">            final String checkerThreadsNumberStr =</span>
<span class="fc" id="L365">                cmdLine.getOptionValue(cliParameterName);</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">            if (CommonUtils.isInt(checkerThreadsNumberStr)) {</span>
<span class="fc" id="L367">                final int checkerThreadsNumber = Integer.parseInt(checkerThreadsNumberStr);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                if (checkerThreadsNumber &lt; 1) {</span>
<span class="fc" id="L369">                    result.add(mustBeGreaterThanZeroMessage);</span>
                }
<span class="fc" id="L371">            }</span>
            else {
<span class="fc" id="L373">                result.add(invalidNumberMessage);</span>
            }
        }
<span class="fc" id="L376">    }</span>

    /**
     * Do execution of CheckStyle based on Command line options.
     * @param commandLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return number of violations
     * @throws IOException if a file could not be read.
     * @throws CheckstyleException if something happens processing the files.
     */
    private static int runCli(CommandLine commandLine, List&lt;File&gt; filesToProcess)
            throws IOException, CheckstyleException {
<span class="fc" id="L388">        int result = 0;</span>

        // create config helper object
<span class="fc" id="L391">        final CliOptions config = convertCliToPojo(commandLine, filesToProcess);</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (commandLine.hasOption(OPTION_T_NAME)) {</span>
            // print AST
<span class="fc" id="L394">            final File file = config.files.get(0);</span>
<span class="fc" id="L395">            final String stringAst = AstTreeStringPrinter.printFileAst(file,</span>
                    JavaParser.Options.WITHOUT_COMMENTS);
<span class="fc" id="L397">            System.out.print(stringAst);</span>
<span class="fc" id="L398">        }</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_CAPITAL_T_NAME)) {</span>
<span class="fc" id="L400">            final File file = config.files.get(0);</span>
<span class="fc" id="L401">            final String stringAst = AstTreeStringPrinter.printFileAst(file,</span>
                    JavaParser.Options.WITH_COMMENTS);
<span class="fc" id="L403">            System.out.print(stringAst);</span>
<span class="fc" id="L404">        }</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_J_NAME)) {</span>
<span class="fc" id="L406">            final File file = config.files.get(0);</span>
<span class="fc" id="L407">            final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);</span>
<span class="fc" id="L408">            System.out.print(stringAst);</span>
<span class="fc" id="L409">        }</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        else if (commandLine.hasOption(OPTION_CAPITAL_J_NAME)) {</span>
<span class="fc" id="L411">            final File file = config.files.get(0);</span>
<span class="fc" id="L412">            final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);</span>
<span class="fc" id="L413">            System.out.print(stringAst);</span>
<span class="fc" id="L414">        }</span>
        else {
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (commandLine.hasOption(OPTION_D_NAME)) {</span>
<span class="fc" id="L417">                final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();</span>
<span class="fc" id="L418">                final ConsoleHandler handler = new ConsoleHandler();</span>
<span class="fc" id="L419">                handler.setLevel(Level.FINEST);</span>
<span class="fc" id="L420">                handler.setFilter(new Filter() {</span>
<span class="fc" id="L421">                    private final String packageName = Main.class.getPackage().getName();</span>

                    @Override
                    public boolean isLoggable(LogRecord record) {
<span class="fc" id="L425">                        return record.getLoggerName().startsWith(packageName);</span>
                    }
                });
<span class="fc" id="L428">                parentLogger.addHandler(handler);</span>
<span class="fc" id="L429">                parentLogger.setLevel(Level.FINEST);</span>
            }
<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (LOG.isDebugEnabled()) {</span>
<span class="fc" id="L432">                LOG.debug(&quot;Checkstyle debug logging enabled&quot;);</span>
<span class="fc" id="L433">                LOG.debug(&quot;Running Checkstyle with version: &quot;</span>
<span class="fc" id="L434">                        + Main.class.getPackage().getImplementationVersion());</span>
            }

            // run Checker
<span class="fc" id="L438">            result = runCheckstyle(config);</span>
        }

<span class="fc" id="L441">        return result;</span>
    }

    /**
     * Util method to convert CommandLine type to POJO object.
     * @param cmdLine command line object
     * @param filesToProcess List of files to process found from the command line.
     * @return command line option as POJO object
     */
    private static CliOptions convertCliToPojo(CommandLine cmdLine, List&lt;File&gt; filesToProcess) {
<span class="fc" id="L451">        final CliOptions conf = new CliOptions();</span>
<span class="fc" id="L452">        conf.format = cmdLine.getOptionValue(OPTION_F_NAME);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (conf.format == null) {</span>
<span class="fc" id="L454">            conf.format = PLAIN_FORMAT_NAME;</span>
        }
<span class="fc" id="L456">        conf.outputLocation = cmdLine.getOptionValue(OPTION_O_NAME);</span>
<span class="fc" id="L457">        conf.configLocation = cmdLine.getOptionValue(OPTION_C_NAME);</span>
<span class="fc" id="L458">        conf.propertiesLocation = cmdLine.getOptionValue(OPTION_P_NAME);</span>
<span class="fc" id="L459">        conf.files = filesToProcess;</span>
<span class="fc" id="L460">        conf.executeIgnoredModules = cmdLine.hasOption(OPTION_EXECUTE_IGNORED_MODULES_NAME);</span>
<span class="fc" id="L461">        final String checkerThreadsNumber = cmdLine.getOptionValue(</span>
                OPTION_CAPITAL_C_NAME, ONE_STRING_VALUE);
<span class="fc" id="L463">        conf.checkerThreadsNumber = Integer.parseInt(checkerThreadsNumber);</span>
<span class="fc" id="L464">        final String treeWalkerThreadsNumber = cmdLine.getOptionValue(</span>
                OPTION_CAPITAL_W_NAME, ONE_STRING_VALUE);
<span class="fc" id="L466">        conf.treeWalkerThreadsNumber = Integer.parseInt(treeWalkerThreadsNumber);</span>
<span class="fc" id="L467">        return conf;</span>
    }

    /**
     * Executes required Checkstyle actions based on passed parameters.
     * @param cliOptions
     *        pojo object that contains all options
     * @return number of violations of ERROR level
     * @throws FileNotFoundException
     *         when output file could not be found
     * @throws CheckstyleException
     *         when properties file could not be loaded
     */
    private static int runCheckstyle(CliOptions cliOptions)
            throws CheckstyleException, FileNotFoundException {
        // setup the properties
        final Properties props;

<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (cliOptions.propertiesLocation == null) {</span>
<span class="fc" id="L486">            props = System.getProperties();</span>
        }
        else {
<span class="fc" id="L489">            props = loadProperties(new File(cliOptions.propertiesLocation));</span>
        }

        // create a configuration
<span class="fc" id="L493">        final ThreadModeSettings multiThreadModeSettings =</span>
                new ThreadModeSettings(
<span class="fc" id="L495">                        cliOptions.checkerThreadsNumber, cliOptions.treeWalkerThreadsNumber);</span>

        final ConfigurationLoader.IgnoredModulesOptions ignoredModulesOptions;
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (cliOptions.executeIgnoredModules) {</span>
<span class="fc" id="L499">            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.EXECUTE;</span>
        }
        else {
<span class="fc" id="L502">            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.OMIT;</span>
        }

<span class="fc" id="L505">        final Configuration config = ConfigurationLoader.loadConfiguration(</span>
<span class="fc" id="L506">                cliOptions.configLocation, new PropertiesExpander(props),</span>
                ignoredModulesOptions, multiThreadModeSettings);

        // create a listener for output
<span class="fc" id="L510">        final AuditListener listener = createListener(cliOptions.format, cliOptions.outputLocation);</span>

        // create RootModule object and run it
        final int errorCounter;
<span class="fc" id="L514">        final ClassLoader moduleClassLoader = Checker.class.getClassLoader();</span>
<span class="fc" id="L515">        final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);</span>

        try {
<span class="fc" id="L518">            rootModule.setModuleClassLoader(moduleClassLoader);</span>
<span class="fc" id="L519">            rootModule.configure(config);</span>
<span class="fc" id="L520">            rootModule.addListener(listener);</span>

            // run RootModule
<span class="fc" id="L523">            errorCounter = rootModule.process(cliOptions.files);</span>
        }
        finally {
<span class="fc" id="L526">            rootModule.destroy();</span>
        }

<span class="fc" id="L529">        return errorCounter;</span>
    }

    /**
     * Creates a new instance of the root module that will control and run
     * Checkstyle.
     * @param name The name of the module. This will either be a short name that
     *        will have to be found or the complete package name.
     * @param moduleClassLoader Class loader used to load the root module.
     * @return The new instance of the root module.
     * @throws CheckstyleException if no module can be instantiated from name
     */
    private static RootModule getRootModule(String name, ClassLoader moduleClassLoader)
            throws CheckstyleException {
<span class="fc" id="L543">        final ModuleFactory factory = new PackageObjectFactory(</span>
<span class="fc" id="L544">                Checker.class.getPackage().getName(), moduleClassLoader);</span>

<span class="fc" id="L546">        return (RootModule) factory.createModule(name);</span>
    }

    /**
     * Loads properties from a File.
     * @param file
     *        the properties file
     * @return the properties in file
     * @throws CheckstyleException
     *         when could not load properties file
     */
    private static Properties loadProperties(File file)
            throws CheckstyleException {
<span class="fc" id="L559">        final Properties properties = new Properties();</span>

<span class="fc" id="L561">        FileInputStream fis = null;</span>
        try {
<span class="fc" id="L563">            fis = new FileInputStream(file);</span>
<span class="fc" id="L564">            properties.load(fis);</span>
        }
<span class="fc" id="L566">        catch (final IOException ex) {</span>
<span class="fc" id="L567">            final LocalizedMessage loadPropertiesExceptionMessage = new LocalizedMessage(0,</span>
                    Definitions.CHECKSTYLE_BUNDLE, LOAD_PROPERTIES_EXCEPTION,
<span class="fc" id="L569">                    new String[] {file.getAbsolutePath()}, null, Main.class, null);</span>
<span class="fc" id="L570">            throw new CheckstyleException(loadPropertiesExceptionMessage.getMessage(), ex);</span>
        }
        finally {
<span class="fc" id="L573">            Closeables.closeQuietly(fis);</span>
        }

<span class="fc" id="L576">        return properties;</span>
    }

    /**
     * Creates the audit listener.
     *
     * @param format format of the audit listener
     * @param outputLocation the location of output
     * @return a fresh new {@code AuditListener}
     * @exception FileNotFoundException when provided output location is not found
     * @noinspection IOResourceOpenedButNotSafelyClosed
     */
    private static AuditListener createListener(String format,
                                                String outputLocation)
            throws FileNotFoundException {
        // setup the output stream
        final OutputStream out;
        final AutomaticBean.OutputStreamOptions closeOutputStream;
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (outputLocation == null) {</span>
<span class="fc" id="L595">            out = System.out;</span>
<span class="fc" id="L596">            closeOutputStream = AutomaticBean.OutputStreamOptions.NONE;</span>
        }
        else {
<span class="fc" id="L599">            out = new FileOutputStream(outputLocation);</span>
<span class="fc" id="L600">            closeOutputStream = AutomaticBean.OutputStreamOptions.CLOSE;</span>
        }

        // setup a listener
        final AuditListener listener;
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (XML_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L606">            listener = new XMLLogger(out, closeOutputStream);</span>
        }
<span class="fc bfc" id="L608" title="All 2 branches covered.">        else if (PLAIN_FORMAT_NAME.equals(format)) {</span>
<span class="fc" id="L609">            listener = new DefaultLogger(out, closeOutputStream, out,</span>
                    AutomaticBean.OutputStreamOptions.NONE);
        }
        else {
<span class="fc bfc" id="L613" title="All 2 branches covered.">            if (closeOutputStream == AutomaticBean.OutputStreamOptions.CLOSE) {</span>
<span class="fc" id="L614">                CommonUtils.close(out);</span>
            }
<span class="fc" id="L616">            final LocalizedMessage outputFormatExceptionMessage = new LocalizedMessage(0,</span>
                    Definitions.CHECKSTYLE_BUNDLE, CREATE_LISTENER_EXCEPTION,
                    new String[] {format, PLAIN_FORMAT_NAME, XML_FORMAT_NAME}, null,
                    Main.class, null);
<span class="fc" id="L620">            throw new IllegalStateException(outputFormatExceptionMessage.getMessage());</span>
        }

<span class="fc" id="L623">        return listener;</span>
    }

    /**
     * Determines the files to process.
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @param filesToProcess
     *        arguments that were not processed yet but shall be
     * @return list of files to process
     */
    private static List&lt;File&gt; getFilesToProcess(List&lt;Pattern&gt; patternsToExclude,
            String... filesToProcess) {
<span class="fc" id="L635">        final List&lt;File&gt; files = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        for (String element : filesToProcess) {</span>
<span class="fc" id="L637">            files.addAll(listFiles(new File(element), patternsToExclude));</span>
        }

<span class="fc" id="L640">        return files;</span>
    }

    /**
     * Traverses a specified node looking for files to check. Found files are added to a specified
     * list. Subdirectories are also traversed.
     * @param node
     *        the node to process
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @return found files
     */
    private static List&lt;File&gt; listFiles(File node, List&lt;Pattern&gt; patternsToExclude) {
        // could be replaced with org.apache.commons.io.FileUtils.list() method
        // if only we add commons-io library
<span class="fc" id="L654">        final List&lt;File&gt; result = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (node.canRead()) {</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">            if (node.isDirectory()) {</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">                if (!isDirectoryExcluded(node.getAbsolutePath(), patternsToExclude)) {</span>
<span class="fc" id="L659">                    final File[] files = node.listFiles();</span>
                    // listFiles() can return null, so we need to check it
<span class="fc bfc" id="L661" title="All 2 branches covered.">                    if (files != null) {</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">                        for (File element : files) {</span>
<span class="fc" id="L663">                            result.addAll(listFiles(element, patternsToExclude));</span>
                        }
                    }
<span class="fc" id="L666">                }</span>
            }
<span class="fc bfc" id="L668" title="All 2 branches covered.">            else if (node.isFile()) {</span>
<span class="fc" id="L669">                result.add(node);</span>
            }
        }
<span class="fc" id="L672">        return result;</span>
    }

    /**
     * Checks if a directory {@code path} should be excluded based on if it matches one of the
     * patterns supplied.
     * @param path The path of the directory to check
     * @param patternsToExclude The list of directory patterns to exclude from searching.
     * @return True if the directory matches one of the patterns.
     */
    private static boolean isDirectoryExcluded(String path, List&lt;Pattern&gt; patternsToExclude) {
<span class="fc" id="L683">        boolean result = false;</span>

<span class="fc bfc" id="L685" title="All 2 branches covered.">        for (Pattern pattern : patternsToExclude) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">            if (pattern.matcher(path).find()) {</span>
<span class="fc" id="L687">                result = true;</span>
<span class="fc" id="L688">                break;</span>
            }
<span class="fc" id="L690">        }</span>

<span class="fc" id="L692">        return result;</span>
    }

    /** Prints the usage information. **/
    private static void printUsage() {
<span class="fc" id="L697">        final HelpFormatter formatter = new HelpFormatter();</span>
<span class="fc" id="L698">        formatter.setWidth(HELP_WIDTH);</span>
<span class="fc" id="L699">        formatter.printHelp(String.format(&quot;java %s [options] -c &lt;config.xml&gt; file...&quot;,</span>
<span class="fc" id="L700">                Main.class.getName()), buildOptions());</span>
<span class="fc" id="L701">    }</span>

    /**
     * Builds and returns list of parameters supported by cli Checkstyle.
     * @return available options
     */
    private static Options buildOptions() {
<span class="fc" id="L708">        final Options options = new Options();</span>
<span class="fc" id="L709">        options.addOption(OPTION_C_NAME, true, &quot;Sets the check configuration file to use.&quot;);</span>
<span class="fc" id="L710">        options.addOption(OPTION_O_NAME, true, &quot;Sets the output file. Defaults to stdout&quot;);</span>
<span class="fc" id="L711">        options.addOption(OPTION_P_NAME, true, &quot;Loads the properties file&quot;);</span>
<span class="fc" id="L712">        options.addOption(OPTION_F_NAME, true, String.format(</span>
                &quot;Sets the output format. (%s|%s). Defaults to %s&quot;,
                PLAIN_FORMAT_NAME, XML_FORMAT_NAME, PLAIN_FORMAT_NAME));
<span class="fc" id="L715">        options.addOption(OPTION_V_NAME, false, &quot;Print product version and exit&quot;);</span>
<span class="fc" id="L716">        options.addOption(OPTION_T_NAME, OPTION_TREE_NAME, false,</span>
                &quot;Print Abstract Syntax Tree(AST) of the file&quot;);
<span class="fc" id="L718">        options.addOption(OPTION_CAPITAL_T_NAME, OPTION_TREE_COMMENT_NAME, false,</span>
                &quot;Print Abstract Syntax Tree(AST) of the file including comments&quot;);
<span class="fc" id="L720">        options.addOption(OPTION_J_NAME, OPTION_JAVADOC_TREE_NAME, false,</span>
                &quot;Print Parse tree of the Javadoc comment&quot;);
<span class="fc" id="L722">        options.addOption(OPTION_CAPITAL_J_NAME, OPTION_TREE_JAVADOC_NAME, false,</span>
                &quot;Print full Abstract Syntax Tree of the file&quot;);
<span class="fc" id="L724">        options.addOption(OPTION_D_NAME, OPTION_DEBUG_NAME, false,</span>
                &quot;Print all debug logging of CheckStyle utility&quot;);
<span class="fc" id="L726">        options.addOption(OPTION_E_NAME, OPTION_EXCLUDE_NAME, true,</span>
                &quot;Directory path to exclude from CheckStyle&quot;);
<span class="fc" id="L728">        options.addOption(OPTION_X_NAME, OPTION_EXCLUDE_REGEXP_NAME, true,</span>
                &quot;Regular expression of directory to exclude from CheckStyle&quot;);
<span class="fc" id="L730">        options.addOption(OPTION_EXECUTE_IGNORED_MODULES_NAME, false,</span>
                &quot;Allows ignored modules to be run.&quot;);
<span class="fc" id="L732">        options.addOption(OPTION_CAPITAL_C_NAME, OPTION_CHECKER_THREADS_NUMBER_NAME, true,</span>
                &quot;(experimental) The number of Checker threads (must be greater than zero)&quot;);
<span class="fc" id="L734">        options.addOption(OPTION_CAPITAL_W_NAME, OPTION_TREE_WALKER_THREADS_NUMBER_NAME, true,</span>
                &quot;(experimental) The number of TreeWalker threads (must be greater than zero)&quot;);
<span class="fc" id="L736">        return options;</span>
    }

    /** Helper structure to clear show what is required for Checker to run. **/
    private static class CliOptions {

        /** Properties file location. */
        private String propertiesLocation;
        /** Config file location. */
        private String configLocation;
        /** Output format. */
        private String format;
        /** Output file location. */
        private String outputLocation;
        /** List of file to validate. */
        private List&lt;File&gt; files;
        /** Switch whether to execute ignored modules or not. */
        private boolean executeIgnoredModules;
        /** The checker threads number. */
        private int checkerThreadsNumber;
        /** The tree walker threads number. */
        private int treeWalkerThreadsNumber;

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>